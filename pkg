#!/usr/bin/python

import argparse
import difflib
import os
import shutil
import sys

from termcolor import cprint

from pkg_helper import (CONFIG, PACKAGES, Package, PackageNotFoundError,
                        SolidPackage, initialise, porting, sanitise_triple,
                        try_find_package)

SKIPPED_FILE_EXT = [
    (".pkg.tar.zst", "package"),
    (".log", "log"),
    (".pkg.tar.zst.sig", "signature"),
]


def yes_or_no(question: str, default: str = "") -> bool:
    while True:
        cprint(question, "yellow", attrs=["bold"], end="")
        yn = " [Y/n]" if default == "y" else " [y/N]" if default == "n" else " [y/n]"
        answer = input(f" {yn} ").lower().strip() or default
        if answer in ["y", "yes"]:
            return True
        elif answer in ["n", "no"]:
            return False
        else:
            cprint("Please answer with 'y' or 'n'", "red", attrs=["bold"])


def do_search(hint: str, target: str = ""):
    result = try_find_package(hint, target=target)
    if isinstance(result, list):
        if len(result) == 0:
            cprint(f"No package found for hint: {hint}", "red", attrs=["bold"])
        else:
            print(f"Multiple packages found:")
            for r in result:
                cprint(f'  {r}', "green", attrs=["bold"])
    else:
        cprint(result, "green", attrs=["bold"])


def do_info(name: str, target: str = ""):
    target = sanitise_triple(target)

    if name not in PACKAGES:
        cprint(f"No package found for '{name}'", "red", attrs=["bold"])
        sys.exit(1)

    p = PACKAGES[name]

    if target and target not in p.triples:
        cprint(f"Package {p.basename} does not support '{target}'", "red", attrs=["bold"])
        sys.exit(1)

    p.print_info(selected_target=target, has_deps=True, has_makedeps=True, has_rebuild=True)


def do_list(target: str, has_deps=False, has_makedeps=False, has_rebuild=False):
    target = sanitise_triple(target)

    for _, p in sorted(PACKAGES.items()):
        if target and target not in p.triples:
            continue  # skip if the target is specified but the package does not support the target
        p.print_info(selected_target=target, has_deps=has_deps, has_makedeps=has_makedeps, has_rebuild=has_rebuild)


def do_diff_package(p: Package, triple1: str, triple2: str):
    triple1 = sanitise_triple(triple1)
    triple2 = sanitise_triple(triple2)

    ports1 = p.get_pkgbuild_path(triple1)
    ports2 = p.get_pkgbuild_path(triple2)

    print(f"diffing {ports1} and {ports2}")

    differences = difflib.unified_diff(
        open(ports1).readlines(),
        open(ports2).readlines(),
        fromfile=f"{p.basename}-{triple1}",
        tofile=f"{p.basename}-{triple2}",
    )

    for line in differences:
        if line.startswith('@@'):
            cprint(line, "yellow", attrs=["bold"], end="")
        elif line.startswith('+'):
            cprint(line, "green", attrs=["bold"], end="")
        elif line.startswith('-'):
            cprint(line, "red", attrs=["bold"], end="")
        else:
            print(line, end="")


def do_port_package(pkg: Package, src_triple: str, dst_triple: str, verbose: bool = False, landing: bool = False):
    src_triple = sanitise_triple(src_triple)
    dst_triple = sanitise_triple(dst_triple)

    if dst_triple in pkg.triples:
        cprint(f"Package {pkg.basename} already supports {dst_triple}", "red", attrs=["bold"])
        sys.exit(1)

    cprint(f"Porting package {pkg.basename} from {src_triple} to {dst_triple}", "green", attrs=["bold"])

    src = SolidPackage(pkg, src_triple)
    driver = porting.PortDriver(src, dst_triple)
    dst = driver.context.dstpkg

    deplist = driver.check_package_deps()
    if deplist.is_empty():
        cprint(f'  dependency check for {pkg.basename} passed', 'green')
    else:
        cprint(f"Cannot port package {pkg.basename} to {dst_triple}: the following dependencies are not met", "red", attrs=["bold"])

        deplist_reasons = {dep.basename: ", ".join(
            (["dep"] if dep in deplist.depends else []) +
            (["makedep"] if dep in deplist.makedepends else []) +
            (["rebuild"] if dep in deplist.rebuild else [])
        ) for dep in set([dep for dep in deplist.depends + deplist.makedepends + deplist.rebuild])}

        for dep, reason in sorted(deplist_reasons.items()):
            cprint(f"  {dep} ({reason})", "red")

        return False

    src_filelist = os.listdir(src.pkgdir)

    files_changed = False

    for f in src_filelist:
        should_skip = False
        for ending, desc in SKIPPED_FILE_EXT:
            if f.endswith(ending):
                if verbose:
                    cprint(f"  skipping '{f}' as it is a {desc}", "yellow", attrs=["bold"])
                should_skip = True
                break  # skip the rest of the endings

        if not os.path.isfile(os.path.join(src.pkgdir, f)):
            if verbose:
                cprint(f"  skipping '{f}/' as it is not a file", "yellow")
            should_skip = True

        if should_skip:
            continue

        driver.add_step(porting.Action.COPY_FILE, os.path.join(src.pkgdir, f), os.path.join(dst.pkgdir, f))

        if src_triple not in f:
            if verbose:
                cprint(f"  no need to rename '{f}': file name doesn't contain {src_triple}", "yellow")
            continue

        # also detect if it contains the triple in the content
        with open(os.path.join(src.pkgdir, f), "r") as file:
            content = file.read()
            if src_triple in content:
                driver.add_step(porting.Action.PATCH_FILE, src_triple, dst_triple, os.path.join(dst.pkgdir, f))
                files_changed |= True
            elif verbose:
                cprint(f"  no need to patch '{f}': file content doesn't contain {src_triple}", "yellow")

        # this file is a target-specific file, rename it
        driver.add_step(porting.Action.RENAME_FILE, os.path.join(dst.pkgdir, f), os.path.join(dst.pkgdir, f.replace(src_triple, dst_triple)))

    driver.add_step(porting.Action.PATCH_FILE, src_triple, dst_triple, os.path.join(dst.pkgdir, "PKGBUILD"))
    if files_changed:
        driver.add_step(porting.Action.UPDPKGSUMS, "", "")

    driver.add_step(porting.Action.PATCH_FILE, src_triple, dst_triple, os.path.join(dst.pkgdir, "lilac.yaml"))

    src_arch = src_triple.split("-")[0]
    dst_arch = dst_triple.split("-")[0]
    driver.add_step(porting.Action.PATCH_FILE, f"build_prefix: mos-{src_arch}", f"build_prefix: mos-{dst_arch}", os.path.join(dst.pkgdir, "lilac.yaml"))
    driver.print_steps()

    if landing:
        result = driver.execute()
        cprint(f"Porting {'succeeded' if result else 'failed'}", "green" if result else "red", attrs=["bold"])

        if not result:
            answer = yes_or_no(f"Do you want to clear '{dst.pkgdir}'?", default='y')
            if answer:
                try:
                    shutil.rmtree(dst.pkgdir)
                except FileNotFoundError:
                    pass
                print(f"Directory '{dst.pkgdir}' removed")
    else:
        print("Dry-run, no changes made")
        print("To actually port the package, use the -y option")


def main():
    parser = argparse.ArgumentParser(
        description='This script helps you to maintain packages in the MOS package repository',
        exit_on_error=True,
    )

    subparser = parser.add_subparsers(dest='command', help='Subcommands')

    base_subparser = argparse.ArgumentParser(add_help=False)
    base_subparser.add_argument('-v', '--verbose', action='store_true', help='Show more information')
    base_subparser.add_argument('-t', '--target', type=str, default=None, help='The target triple of the package')
    base_subparser.add_argument('-f', '--full-names', action='store_true', help='Show full package names')

    list_parser = subparser.add_parser('list', help='List all packages in the repository', parents=[base_subparser])
    list_parser.add_argument('--deps', action='store_true', help='Show package dependencies')
    list_parser.add_argument('--makedeps', action='store_true', help='Show package makedependencies')
    list_parser.add_argument('--rebuild', action='store_true', help='Show packages which triggers the rebuild of this package')

    search_parser = subparser.add_parser('search', help='Search for a package in the repository', parents=[base_subparser])
    search_parser.add_argument('hint', type=str, help='The (partial) name of the package to search')

    info_parser = subparser.add_parser('info', help='Show the information of a package', parents=[base_subparser], aliases=['show'])
    info_parser.add_argument('name', type=str, help='The name of the package to show')

    diffports_parser = subparser.add_parser('diff', help='Diff the ports of a package between two targets', parents=[base_subparser])
    diffports_parser.add_argument('triple1', type=str, help='The first target triple')
    diffports_parser.add_argument('triple2', type=str, help='The second target triple')
    diffports_parser.add_argument('name', type=str, help='The name of the package to diff')

    port_parser = subparser.add_parser('port', help='Port the package from one target to another')
    port_parser.add_argument('triple1', type=str, help='The source target triple')
    port_parser.add_argument('triple2', type=str, help='The destination target triple')
    port_parser.add_argument('name', type=str, help='The name of the package to port')
    port_parser.add_argument('-y', '--yes', action='store_true', help='Do not dry-run')
    port_parser.add_argument('-v', '--verbose', action='store_true', help='Show more information')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    initialise()
    if args.command == "list":
        if args.verbose:
            args.deps = args.makedeps = args.rebuild = True  # show all if verbose
        CONFIG.print_full_pkgname = args.full_names
        do_list(args.target, args.deps, args.makedeps, args.rebuild)
    elif args.command == "info" or args.command == "show":
        CONFIG.print_full_pkgname = args.full_names
        do_info(args.name, args.target)
    elif args.command == "search":
        do_search(args.hint, args.target)
    elif args.command == "diff":
        p = PACKAGES[args.name]
        do_diff_package(p, args.triple1, args.triple2)
    elif args.command == "port":
        p = PACKAGES[args.name]
        do_port_package(p, args.triple1, args.triple2, args.verbose, args.yes)


if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.realpath(__file__)))

    try:
        main()
    except KeyError as e:
        cprint(f"KeyError: {e}, probably misspelled a package name?", "red", attrs=["bold"])
        sys.exit(1)
    except PackageNotFoundError as e:
        cprint(f"Error: {e}", "red", attrs=["bold"])
        sys.exit(1)
    except ValueError as e:
        cprint(f"Error: {e}", "red", attrs=["bold"])
        sys.exit(1)
    except KeyboardInterrupt:
        cprint("Interrupted by user", "red", attrs=["bold"])
        sys.exit(1)
